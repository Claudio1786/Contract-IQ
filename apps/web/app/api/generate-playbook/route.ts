import { NextRequest, NextResponse } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { buildEnhancedPrompt } from '../../../lib/negotiation-intelligence';

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { contractType, scenario, objectives, currentTerms, desiredOutcome } = body;

    // Validate required fields
    if (!contractType || !scenario || !objectives || objectives.length === 0) {
      return NextResponse.json(
        { error: 'Contract type, scenario, and objectives are required' },
        { status: 400 }
      );
    }

    // Build enhanced prompt with market intelligence
    const enhancedPrompt = buildEnhancedPrompt(
      contractType,
      scenario,
      objectives,
      currentTerms,
      desiredOutcome
    );

    console.log('ü§ñ Generating playbook with Gemini...');
    console.log('Enhanced Prompt Length:', enhancedPrompt.length);

    // Get Gemini model
    const model = genAI.getGenerativeModel({ 
      model: 'gemini-1.5-flash',
      generationConfig: {
        temperature: 0.7,
        topK: 1,
        topP: 1,
        maxOutputTokens: 4000,
      },
    });

    // Generate content with Gemini
    const result = await model.generateContent(enhancedPrompt);
    const response = await result.response;
    const text = response.text();

    if (!text) {
      throw new Error('No content generated by Gemini');
    }

    console.log('‚úÖ Playbook generated successfully');
    console.log('Response length:', text.length);

    // Parse the generated content into structured format
    const playbook = parsePlaybookResponse(text, {
      contractType,
      scenario,
      objectives,
      currentTerms,
      desiredOutcome
    });

    return NextResponse.json({ 
      success: true, 
      playbook,
      metadata: {
        promptLength: enhancedPrompt.length,
        responseLength: text.length,
        model: 'gemini-1.5-flash'
      }
    });

  } catch (error: any) {
    console.error('‚ùå Error generating playbook:', error);
    
    return NextResponse.json(
      { 
        error: 'Failed to generate playbook',
        details: error.message,
        type: error.name
      },
      { status: 500 }
    );
  }
}

// Parse Gemini's response into structured playbook format
function parsePlaybookResponse(text: string, metadata: any) {
  const playbook = {
    id: `playbook_${Date.now()}`,
    title: `${metadata.contractType} - ${getScenanioDisplayName(metadata.scenario)}`,
    contractType: metadata.contractType,
    scenario: metadata.scenario,
    objectives: metadata.objectives,
    content: text, // Store full generated content
    createdAt: new Date(),
    
    // Parse structured sections from the text
    sections: parseStructuredSections(text)
  };

  return playbook;
}

function getScenanioDisplayName(scenarioId: string): string {
  const scenarioNames: Record<string, string> = {
    'saas_renewal_price_increase': 'SaaS Renewal Price Increase Mitigation',
    'sla_enhancement': 'Service Level Agreement Enhancement',
    'gdpr_dpa_compliance': 'GDPR Data Processing Agreement Compliance'
  };
  
  return scenarioNames[scenarioId] || scenarioId;
}

function parseStructuredSections(text: string) {
  const sections: Record<string, string> = {};
  
  // Try to parse common sections from the generated content
  const sectionPatterns = [
    { key: 'executiveSummary', patterns: [/EXECUTIVE SUMMARY(.*?)(?=\n##|\n\*\*|$)/is, /Executive Summary(.*?)(?=\n##|\n\*\*|$)/is] },
    { key: 'talkingPoints', patterns: [/BATTLE-TESTED TALKING POINTS(.*?)(?=\n##|\n\*\*|$)/is, /Talking Points(.*?)(?=\n##|\n\*\*|$)/is] },
    { key: 'riskMitigation', patterns: [/RISK MITIGATION(.*?)(?=\n##|\n\*\*|$)/is, /Risk Mitigation(.*?)(?=\n##|\n\*\*|$)/is] },
    { key: 'tactics', patterns: [/NEGOTIATION TACTICS(.*?)(?=\n##|\n\*\*|$)/is, /Tactics(.*?)(?=\n##|\n\*\*|$)/is] },
    { key: 'timeline', patterns: [/TIMELINE & PHASES(.*?)(?=\n##|\n\*\*|$)/is, /Timeline(.*?)(?=\n##|\n\*\*|$)/is] },
    { key: 'successMetrics', patterns: [/SUCCESS METRICS(.*?)(?=\n##|\n\*\*|$)/is, /Success Metrics(.*?)(?=\n##|\n\*\*|$)/is] }
  ];

  for (const section of sectionPatterns) {
    for (const pattern of section.patterns) {
      const match = text.match(pattern);
      if (match && match[1]) {
        sections[section.key] = match[1].trim();
        break;
      }
    }
  }

  return sections;
}