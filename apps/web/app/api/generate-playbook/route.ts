import { NextRequest, NextResponse } from 'next/server';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { buildEnhancedPrompt } from '../../../lib/negotiation-intelligence';

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');

export async function POST(request: NextRequest) {
  try {
    console.log('üì• Playbook generation request received');
    
    const body = await request.json();
    const { contractType, scenario, objectives, currentTerms, desiredOutcome } = body;
    
    // Check if GEMINI_API_KEY is available
    if (!process.env.GEMINI_API_KEY) {
      console.error('‚ùå GEMINI_API_KEY environment variable not set - using fallback');
      
      // Fallback: Generate a basic playbook without AI
      const fallbackPlaybook = generateFallbackPlaybook(contractType, scenario, objectives, currentTerms, desiredOutcome);
      
      return NextResponse.json({ 
        success: true, 
        playbook: fallbackPlaybook,
        metadata: {
          model: 'fallback-template',
          warning: 'Generated using template - AI not available'
        }
      });
    }
    
    console.log('üìã Request data:', { contractType, scenario, objectives });

    // Validate required fields
    if (!contractType || !scenario || !objectives || objectives.length === 0) {
      console.error('‚ùå Missing required fields');
      return NextResponse.json(
        { error: 'Contract type, scenario, and objectives are required' },
        { status: 400 }
      );
    }

    // Build enhanced prompt with market intelligence
    console.log('üîÑ Building enhanced prompt...');
    let enhancedPrompt: string;
    try {
      enhancedPrompt = buildEnhancedPrompt(
        contractType,
        scenario,
        objectives,
        currentTerms,
        desiredOutcome
      );
      console.log('‚úÖ Enhanced prompt built successfully');
    } catch (promptError: any) {
      console.error('‚ùå Error building enhanced prompt:', promptError);
      return NextResponse.json(
        { error: 'Failed to build prompt', details: promptError.message },
        { status: 500 }
      );
    }

    console.log('ü§ñ Generating playbook with Gemini...');
    console.log('Enhanced Prompt Length:', enhancedPrompt.length);

    let text: string;
    try {
      // Get Gemini model
      const model = genAI.getGenerativeModel({ 
        model: 'gemini-1.5-flash',
        generationConfig: {
          temperature: 0.7,
          topK: 1,
          topP: 1,
          maxOutputTokens: 4000,
        },
      });

      // Generate content with Gemini
      const result = await model.generateContent(enhancedPrompt);
      const response = await result.response;
      text = response.text();

      if (!text) {
        throw new Error('No content generated by Gemini');
      }
    } catch (geminiError: any) {
      console.error('‚ùå Gemini API Error:', geminiError);
      return NextResponse.json(
        { 
          error: 'AI generation failed', 
          details: geminiError.message,
          code: geminiError.code || 'GEMINI_ERROR'
        },
        { status: 503 }
      );
    }

    console.log('‚úÖ Playbook generated successfully');
    console.log('Response length:', text.length);

    // Parse the generated content into structured format
    const playbook = parsePlaybookResponse(text, {
      contractType,
      scenario,
      objectives,
      currentTerms,
      desiredOutcome
    });

    return NextResponse.json({ 
      success: true, 
      playbook,
      metadata: {
        promptLength: enhancedPrompt.length,
        responseLength: text.length,
        model: 'gemini-1.5-flash'
      }
    });

  } catch (error: any) {
    console.error('‚ùå Error generating playbook:', error);
    
    return NextResponse.json(
      { 
        error: 'Failed to generate playbook',
        details: error.message,
        type: error.name
      },
      { status: 500 }
    );
  }
}

// Parse Gemini's response into structured playbook format
function parsePlaybookResponse(text: string, metadata: any) {
  const playbook = {
    id: `playbook_${Date.now()}`,
    title: `${metadata.contractType} - ${getScenanioDisplayName(metadata.scenario)}`,
    contractType: metadata.contractType,
    scenario: metadata.scenario,
    objectives: metadata.objectives,
    content: text, // Store full generated content
    createdAt: new Date(),
    
    // Parse structured sections from the text
    sections: parseStructuredSections(text)
  };

  return playbook;
}

function getScenanioDisplayName(scenarioId: string): string {
  const scenarioNames: Record<string, string> = {
    'saas_renewal_price_increase': 'SaaS Renewal Price Increase Mitigation',
    'sla_enhancement': 'Service Level Agreement Enhancement',
    'gdpr_dpa_compliance': 'GDPR Data Processing Agreement Compliance'
  };
  
  return scenarioNames[scenarioId] || scenarioId;
}

function parseStructuredSections(text: string) {
  const sections: Record<string, string> = {};
  
  // Try to parse common sections from the generated content
  const sectionPatterns = [
    { key: 'executiveSummary', patterns: [/EXECUTIVE SUMMARY(.*?)(?=\n##|\n\*\*|$)/is, /Executive Summary(.*?)(?=\n##|\n\*\*|$)/is] },
    { key: 'talkingPoints', patterns: [/BATTLE-TESTED TALKING POINTS(.*?)(?=\n##|\n\*\*|$)/is, /Talking Points(.*?)(?=\n##|\n\*\*|$)/is] },
    { key: 'riskMitigation', patterns: [/RISK MITIGATION(.*?)(?=\n##|\n\*\*|$)/is, /Risk Mitigation(.*?)(?=\n##|\n\*\*|$)/is] },
    { key: 'tactics', patterns: [/NEGOTIATION TACTICS(.*?)(?=\n##|\n\*\*|$)/is, /Tactics(.*?)(?=\n##|\n\*\*|$)/is] },
    { key: 'timeline', patterns: [/TIMELINE & PHASES(.*?)(?=\n##|\n\*\*|$)/is, /Timeline(.*?)(?=\n##|\n\*\*|$)/is] },
    { key: 'successMetrics', patterns: [/SUCCESS METRICS(.*?)(?=\n##|\n\*\*|$)/is, /Success Metrics(.*?)(?=\n##|\n\*\*|$)/is] }
  ];

  for (const section of sectionPatterns) {
    for (const pattern of section.patterns) {
      const match = text.match(pattern);
      if (match && match[1]) {
        sections[section.key] = match[1].trim();
        break;
      }
    }
  }

  return sections;
}

// Generate a fallback playbook when AI is not available
function generateFallbackPlaybook(
  contractType: string, 
  scenario: string, 
  objectives: string[], 
  currentTerms?: string, 
  desiredOutcome?: string
) {
  const fallbackContent = `# ${contractType} - ${getScenanioDisplayName(scenario)}

## Executive Summary
This playbook provides strategic guidance for negotiating your ${contractType} with focus on ${scenario}. The approach below is based on industry best practices and common market benchmarks.

**Note:** This is a template-based playbook. For AI-powered insights and market intelligence, please ensure the system is properly configured with API access.

## Your Negotiation Objectives
${objectives.map(obj => `‚Ä¢ ${obj}`).join('\n')}

${currentTerms ? `\n## Current Situation\n${currentTerms}\n` : ''}
${desiredOutcome ? `\n## Desired Outcome\n${desiredOutcome}\n` : ''}

## Key Talking Points

### 1. Market Position
- Research current market rates for similar agreements
- Prepare benchmarking data to support your position
- Understand industry standard terms and conditions

### 2. Value Proposition
- Clearly articulate the value you bring to the relationship
- Highlight unique capabilities or competitive advantages
- Quantify business impact where possible

### 3. Risk Management
- Identify key risks in the current agreement structure
- Propose balanced risk-sharing mechanisms
- Address compliance and regulatory requirements

## Negotiation Tactics

### Opening Position
- Start with a strong but reasonable initial position
- Support all requests with market data and business rationale
- Be prepared to explain the mutual benefits

### Compromise Strategy
- Identify areas where you can be flexible
- Prepare alternative proposals that achieve similar outcomes
- Consider creative solutions that benefit both parties

### Closing Approach
- Summarize key agreements and outstanding issues
- Set clear next steps and timelines
- Document all agreements in writing

## Success Metrics
- Achievement of primary objectives: ${objectives.slice(0, 3).join(', ')}
- Improved terms compared to current agreement
- Maintained positive relationship with counterparty
- Clear documentation of all agreed terms

## Next Steps
1. Review and customize this playbook based on your specific situation
2. Gather supporting market data and benchmarks
3. Prepare for initial negotiation meeting
4. Document all discussions and agreements

---

*This playbook was generated using template-based guidance. For AI-powered insights with real market intelligence, please contact your administrator to configure the AI system.*`;

  return {
    id: `fallback_${Date.now()}`,
    title: `${contractType} - ${getScenanioDisplayName(scenario)} (Template)`,
    contractType,
    scenario,
    objectives,
    content: fallbackContent,
    createdAt: new Date(),
    sections: {
      executiveSummary: "Template-based playbook providing strategic guidance for contract negotiation.",
      talkingPoints: "Market position, value proposition, and risk management talking points.",
      riskMitigation: "Identify key risks and propose balanced risk-sharing mechanisms.",
      tactics: "Opening position, compromise strategy, and closing approach tactics.",
      timeline: "Review, customize, gather data, prepare, and document process.",
      successMetrics: `Achievement of objectives: ${objectives.slice(0, 3).join(', ')}`
    }
  };
}